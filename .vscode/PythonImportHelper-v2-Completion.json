[
    {
        "label": "joblib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "joblib",
        "description": "joblib",
        "detail": "joblib",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "read_params",
        "importPath": "src.get_data_",
        "description": "src.get_data_",
        "isExtraImport": true,
        "detail": "src.get_data_",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "pprint",
        "importPath": "pprint",
        "description": "pprint",
        "isExtraImport": true,
        "detail": "pprint",
        "documentation": {}
    },
    {
        "label": "pprint",
        "importPath": "pprint",
        "description": "pprint",
        "isExtraImport": true,
        "detail": "pprint",
        "documentation": {}
    },
    {
        "label": "pprint",
        "importPath": "pprint",
        "description": "pprint",
        "isExtraImport": true,
        "detail": "pprint",
        "documentation": {}
    },
    {
        "label": "_transformer",
        "importPath": "prediction_service.pred_transform",
        "description": "prediction_service.pred_transform",
        "isExtraImport": true,
        "detail": "prediction_service.pred_transform",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "get_data_",
        "importPath": "src",
        "description": "src",
        "isExtraImport": true,
        "detail": "src",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "MultiLabelBinarizer",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "set_config",
        "importPath": "sklearn",
        "description": "sklearn",
        "isExtraImport": true,
        "detail": "sklearn",
        "documentation": {}
    },
    {
        "label": "category_encoders",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "category_encoders",
        "description": "category_encoders",
        "detail": "category_encoders",
        "documentation": {}
    },
    {
        "label": "read_params",
        "importPath": "get_data_",
        "description": "get_data_",
        "isExtraImport": true,
        "detail": "get_data_",
        "documentation": {}
    },
    {
        "label": "get_data_frame",
        "importPath": "get_data_",
        "description": "get_data_",
        "isExtraImport": true,
        "detail": "get_data_",
        "documentation": {}
    },
    {
        "label": "read_params",
        "importPath": "get_data_",
        "description": "get_data_",
        "isExtraImport": true,
        "detail": "get_data_",
        "documentation": {}
    },
    {
        "label": "read_params",
        "importPath": "get_data_",
        "description": "get_data_",
        "isExtraImport": true,
        "detail": "get_data_",
        "documentation": {}
    },
    {
        "label": "yaml",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "yaml",
        "description": "yaml",
        "detail": "yaml",
        "documentation": {}
    },
    {
        "label": "mlflow",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "mlflow",
        "description": "mlflow",
        "detail": "mlflow",
        "documentation": {}
    },
    {
        "label": "MlflowClient",
        "importPath": "mlflow.tracking",
        "description": "mlflow.tracking",
        "isExtraImport": true,
        "detail": "mlflow.tracking",
        "documentation": {}
    },
    {
        "label": "train_test_split",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "RandomForestRegressor",
        "importPath": "sklearn.ensemble",
        "description": "sklearn.ensemble",
        "isExtraImport": true,
        "detail": "sklearn.ensemble",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "urlparse",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "hyper_parameter_tuning",
        "importPath": "model_training_and_hyperParameter_tuning",
        "description": "model_training_and_hyperParameter_tuning",
        "isExtraImport": true,
        "detail": "model_training_and_hyperParameter_tuning",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "url_for",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "form_response",
        "importPath": "prediction_service.pred_service",
        "description": "prediction_service.pred_service",
        "isExtraImport": true,
        "detail": "prediction_service.pred_service",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "form_response",
        "kind": 2,
        "importPath": "prediction_service.pred_service",
        "description": "prediction_service.pred_service",
        "peekOfCode": "def form_response(df):\n    try:\n        config = get_args_config()\n        prod_model_path = config['ml_flow_config']['production_model_path']\n        data = pd.DataFrame(df, columns=df.keys(), index=[0]).copy()\n        data_for_pred =  _transformer(data, config)\n        prod_model = joblib.load(prod_model_path)\n        pred = prod_model.predict(data_for_pred)\n        print(pred)\n        val = round(pred.tolist()[0], 2)",
        "detail": "prediction_service.pred_service",
        "documentation": {}
    },
    {
        "label": "get_args_config",
        "kind": 2,
        "importPath": "prediction_service.pred_service",
        "description": "prediction_service.pred_service",
        "peekOfCode": "def get_args_config():\n    args = argparse.ArgumentParser()\n    args.add_argument(\"--config\", default=\"params.yaml\")\n    parsed_args = args.parse_args()\n    config = read_params(config_path=parsed_args.config)\n    return config",
        "detail": "prediction_service.pred_service",
        "documentation": {}
    },
    {
        "label": "model_path",
        "kind": 5,
        "importPath": "prediction_service.pred_service",
        "description": "prediction_service.pred_service",
        "peekOfCode": "model_path = os.path.join(\"prediction_service\",\"poduction_model.pkl\") \ndef form_response(df):\n    try:\n        config = get_args_config()\n        prod_model_path = config['ml_flow_config']['production_model_path']\n        data = pd.DataFrame(df, columns=df.keys(), index=[0]).copy()\n        data_for_pred =  _transformer(data, config)\n        prod_model = joblib.load(prod_model_path)\n        pred = prod_model.predict(data_for_pred)\n        print(pred)",
        "detail": "prediction_service.pred_service",
        "documentation": {}
    },
    {
        "label": "lister",
        "kind": 2,
        "importPath": "prediction_service.pred_transform",
        "description": "prediction_service.pred_transform",
        "peekOfCode": "def lister(val):\n    '''\n    this function takes the value and return it in a list\n    '''\n    if ',' in val:\n        ls = val.split(', ')\n        return ls\n    else:\n        return [val]\ndef spacer(val):",
        "detail": "prediction_service.pred_transform",
        "documentation": {}
    },
    {
        "label": "spacer",
        "kind": 2,
        "importPath": "prediction_service.pred_transform",
        "description": "prediction_service.pred_transform",
        "peekOfCode": "def spacer(val):\n    if ',' in val:\n        n_val =str(val).replace(',', ', ', 20)\n        return n_val\n    else:\n        return val\n# if __name__ == \"__main__\":\n#     d = {'online_order_Yes': '1', 'book_table_Yes': '0', 'cost_per_person': '500', 'rest_type': 'Casual Dining, Cafe', 'loc_pincode': '380068', 'cuisines': 'African,Andhra,Asian'}\n#     data = pd.DataFrame(d, columns=d.keys(), index=[0]).copy()\n#     args = argparse.ArgumentParser()",
        "detail": "prediction_service.pred_transform",
        "documentation": {}
    },
    {
        "label": "CompareModels",
        "kind": 6,
        "importPath": "src.compare_model_plotter",
        "description": "src.compare_model_plotter",
        "peekOfCode": "class CompareModels:\n    def __init__(self):\n        import pandas as pd\n        self._models = pd.DataFrame(\n            data=['r', 'R^2', 'RMSE', 'RMSRE', 'MAPE'],\n            columns=['Model']\n        ).set_index(keys='Model')\n    def add(self, model_name, y_test, y_pred):\n        import numpy as np\n        from sklearn.metrics import r2_score, mean_squared_error",
        "detail": "src.compare_model_plotter",
        "documentation": {}
    },
    {
        "label": "feature_engine",
        "kind": 2,
        "importPath": "src.feature_engineering",
        "description": "src.feature_engineering",
        "peekOfCode": "def feature_engine(config_path):\n    config = read_params(config_path)\n    df = get_data_frame(config_path)\n    # Handling the Feature : online_order\n    '''\n    One-Hot Encode the Feature : online_order\n    '''\n    df = pd.get_dummies(\n        df, columns=['online_order'], drop_first=True, dtype=float)\n    # Handling the Feature : book_table",
        "detail": "src.feature_engineering",
        "documentation": {}
    },
    {
        "label": "lister",
        "kind": 2,
        "importPath": "src.feature_engineering",
        "description": "src.feature_engineering",
        "peekOfCode": "def lister(val):\n    '''\n    this function takes the value and return it in a list\n    '''\n    if ',' in val:\n        ls = val.split(', ')\n        return ls\n    else:\n        return [val]\nif __name__ == \"__main__\":",
        "detail": "src.feature_engineering",
        "documentation": {}
    },
    {
        "label": "read_params",
        "kind": 2,
        "importPath": "src.get_data_",
        "description": "src.get_data_",
        "peekOfCode": "def read_params(config_path):\n    '''\n    Read the params.yaml file and return a dictionary with various parameters along with its values\n    '''\n    with open(config_path) as yaml_file:\n        config = yaml.safe_load(yaml_file)\n    return config \ndef get_data_frame(config_path):\n    '''\n    Read the CSV file from the local directory and return a pandas dataframe",
        "detail": "src.get_data_",
        "documentation": {}
    },
    {
        "label": "get_data_frame",
        "kind": 2,
        "importPath": "src.get_data_",
        "description": "src.get_data_",
        "peekOfCode": "def get_data_frame(config_path):\n    '''\n    Read the CSV file from the local directory and return a pandas dataframe\n    '''\n    config = read_params(config_path)\n    data_path = config['data_source']['local_data_source']['process_data_source']\n    sample_ = config['data_source']['local_data_source']['data_sample']\n    df = pd.read_csv(data_path, sep=',')\n    return df          #df.sample(n=sample_)\nif __name__ == \"__main__\":",
        "detail": "src.get_data_",
        "documentation": {}
    },
    {
        "label": "log_production_model",
        "kind": 2,
        "importPath": "src.ml_flow_log_production",
        "description": "src.ml_flow_log_production",
        "peekOfCode": "def log_production_model(config_path):\n    config = read_params(config_path)\n    mlflow_config = config[\"ml_flow_config\"]\n    model_name = mlflow_config[\"registered_model_name\"]\n    remote_server_uri = mlflow_config[\"remote_server_uri\"]\n    mlflow.set_tracking_uri(remote_server_uri)\n    runs = mlflow.search_runs(search_all_experiments=True) # it will return a dataframe\n    # runs.to_csv('runs.csv')\n    lowest = runs[\"metrics.MAE\"].sort_values(ascending=True)[0]\n    lowest_run_id = runs[runs[\"metrics.MAE\"] == lowest][\"run_id\"][0]",
        "detail": "src.ml_flow_log_production",
        "documentation": {}
    },
    {
        "label": "hyper_parameter_tuning",
        "kind": 2,
        "importPath": "src.model_training_and_hyperParameter_tuning",
        "description": "src.model_training_and_hyperParameter_tuning",
        "peekOfCode": "def hyper_parameter_tuning(X_train, y_train, random_seed):\n    # define random parameters grid\n    n_estimators = [5,12,21,51,101] # number of trees in the random forest\n    max_features = ['sqrt'] # number of features in consideration at every split\n    max_depth = [int(x) for x in np.linspace(10, 120, num = 12)] # maximum number of levels allowed in each decision tree\n    min_samples_split = [2, 6, 10] # minimum sample number to split a node\n    min_samples_leaf = [1, 3, 4] # minimum sample number that can be stored in a leaf node\n    bootstrap = [True, False] # method used to sample data points\n    random_grid = {'n_estimators': n_estimators,\n                    'max_features': max_features,",
        "detail": "src.model_training_and_hyperParameter_tuning",
        "documentation": {}
    },
    {
        "label": "predict_on_test_data",
        "kind": 2,
        "importPath": "src.train_and_eval",
        "description": "src.train_and_eval",
        "peekOfCode": "def predict_on_test_data(model,X_test):\n    y_pred = model.predict(X_test)\n    return y_pred\ndef get_metrics(y_true, y_pred):\n    from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score\n    mae = mean_absolute_error(y_true, y_pred)\n    mse = mean_squared_error(y_true, y_pred)\n    rmse = mean_squared_error(y_true, y_pred, squared=False)\n    r2 = r2_score(y_true, y_pred)\n    return {'MAE': round(mae, 3), 'MSE': round(mse, 3), 'RMSE': round(rmse, 3), 'R2': round(r2, 3)}",
        "detail": "src.train_and_eval",
        "documentation": {}
    },
    {
        "label": "get_metrics",
        "kind": 2,
        "importPath": "src.train_and_eval",
        "description": "src.train_and_eval",
        "peekOfCode": "def get_metrics(y_true, y_pred):\n    from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score\n    mae = mean_absolute_error(y_true, y_pred)\n    mse = mean_squared_error(y_true, y_pred)\n    rmse = mean_squared_error(y_true, y_pred, squared=False)\n    r2 = r2_score(y_true, y_pred)\n    return {'MAE': round(mae, 3), 'MSE': round(mse, 3), 'RMSE': round(rmse, 3), 'R2': round(r2, 3)}\ndef create_compare_plot(y_true, y_pred, compare_plot_path):\n    from compare_model_plotter import CompareModels\n    plot = CompareModels()",
        "detail": "src.train_and_eval",
        "documentation": {}
    },
    {
        "label": "create_compare_plot",
        "kind": 2,
        "importPath": "src.train_and_eval",
        "description": "src.train_and_eval",
        "peekOfCode": "def create_compare_plot(y_true, y_pred, compare_plot_path):\n    from compare_model_plotter import CompareModels\n    plot = CompareModels()\n    plot.add(model_name='Random Forest Regression', y_test=y_true, y_pred=y_pred)\n    plot.show(compare_plot_path)\n#-----------------------------------------------------------------------\ndef train_and_evaluate(config_path):\n    config = read_params(config_path)\n    train_and_eval_data_path = config[\"data_source\"][\"local_data_source\"]['processed_data_train_and_eval']\n    random_state = config[\"base\"][\"random_seed\"]",
        "detail": "src.train_and_eval",
        "documentation": {}
    },
    {
        "label": "train_and_evaluate",
        "kind": 2,
        "importPath": "src.train_and_eval",
        "description": "src.train_and_eval",
        "peekOfCode": "def train_and_evaluate(config_path):\n    config = read_params(config_path)\n    train_and_eval_data_path = config[\"data_source\"][\"local_data_source\"]['processed_data_train_and_eval']\n    random_state = config[\"base\"][\"random_seed\"]\n    test_size = config[\"base\"][\"test_size\"]\n    # model_dir = config[\"model_dir\"]\n    compare_plot_path = config['metrics_path']['compare_plot_path']\n    random_seed = config['base']['random_seed']\n    df = pd.read_csv(train_and_eval_data_path, sep=',')\n    X = df.drop(['rate'], axis=1)",
        "detail": "src.train_and_eval",
        "documentation": {}
    },
    {
        "label": "dt_now",
        "kind": 5,
        "importPath": "src.train_and_eval",
        "description": "src.train_and_eval",
        "peekOfCode": "dt_now = dt.now()\nexperi_time = dt_now.strftime(\"%m/%d/%Y\")\nrun_time = dt_now.strftime(\"%m/%d/%Y, %H:%M:%S\")\n#-------------------PREDICTION METRICS---------------------------\ndef predict_on_test_data(model,X_test):\n    y_pred = model.predict(X_test)\n    return y_pred\ndef get_metrics(y_true, y_pred):\n    from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score\n    mae = mean_absolute_error(y_true, y_pred)",
        "detail": "src.train_and_eval",
        "documentation": {}
    },
    {
        "label": "experi_time",
        "kind": 5,
        "importPath": "src.train_and_eval",
        "description": "src.train_and_eval",
        "peekOfCode": "experi_time = dt_now.strftime(\"%m/%d/%Y\")\nrun_time = dt_now.strftime(\"%m/%d/%Y, %H:%M:%S\")\n#-------------------PREDICTION METRICS---------------------------\ndef predict_on_test_data(model,X_test):\n    y_pred = model.predict(X_test)\n    return y_pred\ndef get_metrics(y_true, y_pred):\n    from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score\n    mae = mean_absolute_error(y_true, y_pred)\n    mse = mean_squared_error(y_true, y_pred)",
        "detail": "src.train_and_eval",
        "documentation": {}
    },
    {
        "label": "run_time",
        "kind": 5,
        "importPath": "src.train_and_eval",
        "description": "src.train_and_eval",
        "peekOfCode": "run_time = dt_now.strftime(\"%m/%d/%Y, %H:%M:%S\")\n#-------------------PREDICTION METRICS---------------------------\ndef predict_on_test_data(model,X_test):\n    y_pred = model.predict(X_test)\n    return y_pred\ndef get_metrics(y_true, y_pred):\n    from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score\n    mae = mean_absolute_error(y_true, y_pred)\n    mse = mean_squared_error(y_true, y_pred)\n    rmse = mean_squared_error(y_true, y_pred, squared=False)",
        "detail": "src.train_and_eval",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def root():\n    return render_template('index.html')\n@app.route('/predict', methods=['GET', \"POST\"])\ndef predict_page():\n    if request.method == \"POST\":\n        try:\n            if request.form:\n                data_req = dict(request.form)\n                print(data_req)\n                response = form_response(data_req)",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "predict_page",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def predict_page():\n    if request.method == \"POST\":\n        try:\n            if request.form:\n                data_req = dict(request.form)\n                print(data_req)\n                response = form_response(data_req)\n                return render_template('predict.html', result=response)\n            # elif request.json:\n                # response = prediction.api_response(request.json)",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "app = Flask(__name__)\napp.template_folder='webapp/templates'\napp.static_folder='webapp/static'\n@app.route('/', methods=['GET'])\ndef root():\n    return render_template('index.html')\n@app.route('/predict', methods=['GET', \"POST\"])\ndef predict_page():\n    if request.method == \"POST\":\n        try:",
        "detail": "app",
        "documentation": {}
    }
]