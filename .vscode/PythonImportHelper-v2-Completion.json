[
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "joblib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "joblib",
        "description": "joblib",
        "detail": "joblib",
        "documentation": {}
    },
    {
        "label": "MultiLabelBinarizer",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "set_config",
        "importPath": "sklearn",
        "description": "sklearn",
        "isExtraImport": true,
        "detail": "sklearn",
        "documentation": {}
    },
    {
        "label": "category_encoders",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "category_encoders",
        "description": "category_encoders",
        "detail": "category_encoders",
        "documentation": {}
    },
    {
        "label": "read_params",
        "importPath": "get_data_",
        "description": "get_data_",
        "isExtraImport": true,
        "detail": "get_data_",
        "documentation": {}
    },
    {
        "label": "get_data_frame",
        "importPath": "get_data_",
        "description": "get_data_",
        "isExtraImport": true,
        "detail": "get_data_",
        "documentation": {}
    },
    {
        "label": "read_params",
        "importPath": "get_data_",
        "description": "get_data_",
        "isExtraImport": true,
        "detail": "get_data_",
        "documentation": {}
    },
    {
        "label": "yaml",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "yaml",
        "description": "yaml",
        "detail": "yaml",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "train_test_split",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "RandomForestRegressor",
        "importPath": "sklearn.ensemble",
        "description": "sklearn.ensemble",
        "isExtraImport": true,
        "detail": "sklearn.ensemble",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "mlflow",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "mlflow",
        "description": "mlflow",
        "detail": "mlflow",
        "documentation": {}
    },
    {
        "label": "urlparse",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "hyper_parameter_tuning",
        "importPath": "model_training_and_hyperParameter_tuning",
        "description": "model_training_and_hyperParameter_tuning",
        "isExtraImport": true,
        "detail": "model_training_and_hyperParameter_tuning",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "feature_engine",
        "kind": 2,
        "importPath": "src.feature_engineering",
        "description": "src.feature_engineering",
        "peekOfCode": "def feature_engine(config_path):\n    config = read_params(config_path)\n    df = get_data_frame(config_path)\n    # Handling the Feature : online_order\n    '''\n    One-Hot Encode the Feature : online_order\n    '''\n    df = pd.get_dummies(\n        df, columns=['online_order'], drop_first=True, dtype=float)\n    # Handling the Feature : book_table",
        "detail": "src.feature_engineering",
        "documentation": {}
    },
    {
        "label": "lister",
        "kind": 2,
        "importPath": "src.feature_engineering",
        "description": "src.feature_engineering",
        "peekOfCode": "def lister(val):\n    '''\n    this function takes the value and return it in a list\n    '''\n    if ',' in val:\n        ls = val.split(', ')\n        return ls\n    else:\n        return [val]\nif __name__ == \"__main__\":",
        "detail": "src.feature_engineering",
        "documentation": {}
    },
    {
        "label": "read_params",
        "kind": 2,
        "importPath": "src.get_data_",
        "description": "src.get_data_",
        "peekOfCode": "def read_params(config_path):\n    '''\n    Read the params.yaml file and return a dictionary with various parameters along with its values\n    '''\n    with open(config_path) as yaml_file:\n        config = yaml.safe_load(yaml_file)\n    return config \ndef get_data_frame(config_path):\n    '''\n    Read the CSV file from the local directory and return a pandas dataframe",
        "detail": "src.get_data_",
        "documentation": {}
    },
    {
        "label": "get_data_frame",
        "kind": 2,
        "importPath": "src.get_data_",
        "description": "src.get_data_",
        "peekOfCode": "def get_data_frame(config_path):\n    '''\n    Read the CSV file from the local directory and return a pandas dataframe\n    '''\n    config = read_params(config_path)\n    data_path = config['data_source']['local_data_source']['process_data_source']\n    sample_ = config['data_source']['local_data_source']['data_sample']\n    df = pd.read_csv(data_path, sep=',')\n    return df          #df.sample(n=sample_)\nif __name__ == \"__main__\":",
        "detail": "src.get_data_",
        "documentation": {}
    },
    {
        "label": "hyper_parameter_tuning",
        "kind": 2,
        "importPath": "src.model_training_and_hyperParameter_tuning",
        "description": "src.model_training_and_hyperParameter_tuning",
        "peekOfCode": "def hyper_parameter_tuning(X_train, y_train, random_seed):\n    # define random parameters grid\n    n_estimators = [5,12,21,51,101] # number of trees in the random forest\n    max_features = ['sqrt'] # number of features in consideration at every split\n    max_depth = [int(x) for x in np.linspace(10, 120, num = 12)] # maximum number of levels allowed in each decision tree\n    min_samples_split = [2, 6, 10] # minimum sample number to split a node\n    min_samples_leaf = [1, 3, 4] # minimum sample number that can be stored in a leaf node\n    bootstrap = [True, False] # method used to sample data points\n    random_grid = {'n_estimators': n_estimators,\n                    'max_features': max_features,",
        "detail": "src.model_training_and_hyperParameter_tuning",
        "documentation": {}
    },
    {
        "label": "predict_on_test_data",
        "kind": 2,
        "importPath": "src.train_and_eval",
        "description": "src.train_and_eval",
        "peekOfCode": "def predict_on_test_data(model,X_test):\n    y_pred = model.predict(X_test)\n    return y_pred\ndef get_metrics(y_true, y_pred):\n    from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score\n    mae = mean_absolute_error(y_true, y_pred)\n    mse = mean_squared_error(y_true, y_pred)\n    rmse = mean_squared_error(y_true, y_pred, squared=False)\n    r2 = r2_score(y_true, y_pred)\n    return {'MAE': round(mae, 3), 'MSE': round(mse, 3), 'RMSE': round(rmse, 3), 'R2': round(r2, 3)}",
        "detail": "src.train_and_eval",
        "documentation": {}
    },
    {
        "label": "get_metrics",
        "kind": 2,
        "importPath": "src.train_and_eval",
        "description": "src.train_and_eval",
        "peekOfCode": "def get_metrics(y_true, y_pred):\n    from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score\n    mae = mean_absolute_error(y_true, y_pred)\n    mse = mean_squared_error(y_true, y_pred)\n    rmse = mean_squared_error(y_true, y_pred, squared=False)\n    r2 = r2_score(y_true, y_pred)\n    return {'MAE': round(mae, 3), 'MSE': round(mse, 3), 'RMSE': round(rmse, 3), 'R2': round(r2, 3)}\ndef create_compare_plot(y_true, y_pred, compare_plot_path):\n    from compare_model_plotter import CompareModels\n    plot = CompareModels()",
        "detail": "src.train_and_eval",
        "documentation": {}
    },
    {
        "label": "create_compare_plot",
        "kind": 2,
        "importPath": "src.train_and_eval",
        "description": "src.train_and_eval",
        "peekOfCode": "def create_compare_plot(y_true, y_pred, compare_plot_path):\n    from compare_model_plotter import CompareModels\n    plot = CompareModels()\n    plot.add(model_name='Random Forest Regression', y_test=y_true, y_pred=y_pred)\n    plot.show(compare_plot_path)\n#-----------------------------------------------------------------------\ndef train_and_evaluate(config_path):\n    config = read_params(config_path)\n    train_and_eval_data_path = config[\"data_source\"][\"local_data_source\"]['processed_data_train_and_eval']\n    random_state = config[\"base\"][\"random_seed\"]",
        "detail": "src.train_and_eval",
        "documentation": {}
    },
    {
        "label": "train_and_evaluate",
        "kind": 2,
        "importPath": "src.train_and_eval",
        "description": "src.train_and_eval",
        "peekOfCode": "def train_and_evaluate(config_path):\n    config = read_params(config_path)\n    train_and_eval_data_path = config[\"data_source\"][\"local_data_source\"]['processed_data_train_and_eval']\n    random_state = config[\"base\"][\"random_seed\"]\n    test_size = config[\"base\"][\"test_size\"]\n    # model_dir = config[\"model_dir\"]\n    compare_plot_path = config['metrics_path']['compare_plot_path']\n    random_seed = config['base']['random_seed']\n    df = pd.read_csv(train_and_eval_data_path, sep=',')\n    X = df.drop(['rate'], axis=1)",
        "detail": "src.train_and_eval",
        "documentation": {}
    },
    {
        "label": "dt_now",
        "kind": 5,
        "importPath": "src.train_and_eval",
        "description": "src.train_and_eval",
        "peekOfCode": "dt_now = dt.now()\nexperi_time = dt_now.strftime(\"%m/%d/%Y\")\nrun_time = dt_now.strftime(\"%m/%d/%Y, %H:%M:%S\")\n#-------------------PREDICTION METRICS---------------------------\ndef predict_on_test_data(model,X_test):\n    y_pred = model.predict(X_test)\n    return y_pred\ndef get_metrics(y_true, y_pred):\n    from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score\n    mae = mean_absolute_error(y_true, y_pred)",
        "detail": "src.train_and_eval",
        "documentation": {}
    },
    {
        "label": "experi_time",
        "kind": 5,
        "importPath": "src.train_and_eval",
        "description": "src.train_and_eval",
        "peekOfCode": "experi_time = dt_now.strftime(\"%m/%d/%Y\")\nrun_time = dt_now.strftime(\"%m/%d/%Y, %H:%M:%S\")\n#-------------------PREDICTION METRICS---------------------------\ndef predict_on_test_data(model,X_test):\n    y_pred = model.predict(X_test)\n    return y_pred\ndef get_metrics(y_true, y_pred):\n    from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score\n    mae = mean_absolute_error(y_true, y_pred)\n    mse = mean_squared_error(y_true, y_pred)",
        "detail": "src.train_and_eval",
        "documentation": {}
    },
    {
        "label": "run_time",
        "kind": 5,
        "importPath": "src.train_and_eval",
        "description": "src.train_and_eval",
        "peekOfCode": "run_time = dt_now.strftime(\"%m/%d/%Y, %H:%M:%S\")\n#-------------------PREDICTION METRICS---------------------------\ndef predict_on_test_data(model,X_test):\n    y_pred = model.predict(X_test)\n    return y_pred\ndef get_metrics(y_true, y_pred):\n    from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score\n    mae = mean_absolute_error(y_true, y_pred)\n    mse = mean_squared_error(y_true, y_pred)\n    rmse = mean_squared_error(y_true, y_pred, squared=False)",
        "detail": "src.train_and_eval",
        "documentation": {}
    }
]